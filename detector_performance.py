#!/usr/bin/env pythonimport sysimport osfrom argparse import ArgumentParser, RawTextHelpFormatterimport numpy as npfrom scipy.optimize import newtonimport matplotlib.pylab as pltdef CTI_E(Ein, CTIref, Eref, beta):    """Energy dependent CTI function.    Args:        Ein: Input energy        CTIref: CTI at the reference energy        Eref: CTI reference energy        beta: energy dependence (E**-beta)    Returns:        cti: CTI at energy Ein    """    return CTIref * (Ein / Eref)**(-beta)def CTE_X_Y(X, Y, pCTI, sCTI):    """CTE loss factor at X, Y    Args:        X: pixel X position        Y: pixel Y position        pCTI: parallel CTI        sCTI: serial CTI    Returns:        cte: The CTE factor at X, Y for the given parallel and serial             CTI values.    """    cte = (1.0 - pCTI)**Y * (1.0 - sCTI)**X    return ctedef Eout(en, x, y, pctiref, sctiref, eref, beta):    """Computes the energy after CTI losses are applied.    Args:        en: Input energy        x: pixel X position        y: pixel Y position        pCTIref: parallel CTI at the reference energy        sCTIref: serial CTI at the reference energy        Eref: CTI rEference energy        beta: CTI energy dependence (E**-beta)    Returns:        eout: The energy at X, Y after CTI losses.    """    pcti = CTI_E(en, pctiref, eref, beta)    scti = CTI_E(en, sctiref, eref, beta)    cte = CTE_X_Y(x, y, pcti, scti)    # Apply the losses to the input energy    return cte * endef fcn(en, emin, x, y, pctiref, sctiref, eref, beta):    """Function whose root is wanted.    This function is used by the root finding secant method, to    find the x-value, x0, where F(x) = F(x0). In this case,    F(x) = Eout(en) and F(x0) = emin.    Args:        en: energy        emin: required energy after CTI losses are applied        x: pixel X position        y: pixel Y position        pCTIref: parallel CTI at the reference energy        sCTIref: serial CTI at the reference energy        Eref: CTI rEference energy        beta: CTI energy dependence (E**-beta)    Returns:        eout: The energy at X, Y which gives emin after CTI losses.    """    eout = Eout(en, x, y, pctiref, sctiref, eref, beta)    return eout - eminprog = (os.path.realpath(__file__)).split(os.sep)[-1]description = 'Detector performance - Estimates the minimum detectable energy + FWHM'epilog = ''parser = ArgumentParser(prog=prog,                        description=description,                        epilog=epilog,                        formatter_class=RawTextHelpFormatter)parser.add_argument('--thresh', default=100.0, type=float,                    help='Threshold energy (default: %(default)s)')parser.add_argument('--pcti', default=2.5e-5, type=float,                    help='Parallel CTI (default: %(default)s)')parser.add_argument('--scti', default=2.5e-5, type=float,                    help='Serial CTI (default: %(default)s)')parser.add_argument('--eref', default=5895.5, type=float,                    help='CTI reference energy (default: %(default)s)')parser.add_argument('--beta', default=0.7, type=float,                    help='CTI beta parameter (default: %(default)s)')parser.add_argument('--Tinput', default=-120.0, type=float,                    help='CCD_Temp (default: %(default)s)')parser.add_argument('--efwhm', default=5895.5, type=float,                    help='Energy at which FWHM is refived %(default)s)')parser.add_argument('--noiseBase', default=4.5, type=float,                    help='Noise base, in [e-/s] (default: %(default)s)')parser.add_argument('--opNoise', default=1.0, type=float,                    help='diffuse optical bg noise (default: %(default)s)')parser.add_argument('--timeExpo', default=5.0, type=float,                    help='Frame exposure time (default: %(default)s)')args = parser.parse_args(sys.argv[1:])print(args)thresh = args.threshpctiref = args.pctisctiref = args.sctieref = args.erefbeta = args.betaTinput = args.Tinputefwhm = args.efwhmnoiseBase = args.noiseBaseopNoise = args.opNoisetimeExpo = args.timeExposigma_th = 5omega = 3.65fano =  0.115# Derive an approximation of the uncertanties on the amount of charge losses.# For now, simply use the square root of the average expected losses multiplied by 0.5# This assumes that the average capture probability is Pc = 0.5, and considers the capture as a binomial process# The st dev of a binomial process is np(1-p)# Here the average losses are equal to np (number of traps x transfers x capture probability)# In the formula below I'm therefore assuming that p = 0.5 (1-p)=0.5cti_average_losses = efwhm-Eout(efwhm, 2250, 2250, pctiref, sctiref, eref, beta)sigma_cti_average_losses_binomial = np.sqrt(cti_average_losses*0.5)print(f'CTI Binomial formula sigma = {sigma_cti_average_losses_binomial:.2f}')# Here I use the estimate CTI sigma from R. Ambrosi's paper.ctepe = 1.0-CTI_E(efwhm, pctiref, eref, beta)ctese = 1.0-CTI_E(efwhm, sctiref, eref, beta)sigma_cti_average_losses = np.sqrt(2.0 * efwhm / omega * ((1.-ctepe**2250) + ctepe**2250*(1.-ctese**2250))) print(f'CTI ambrosi formula sigma = {sigma_cti_average_losses:.2f}')# Dark current values as a function of Temp, from Steve Parson (table in email 5 June 2024)# OU values are in e-/pixel/s# DC component must be multiplied by frame Expo timeT = np.flip(np.array([-95.0, -100.0, -105.0, -110.0, -115.0, -120.0, -125.0, -130.0]))dc_ft_irr = np.flip(np.array([0.460, 0.252, 0.121, 0.108 , 0.060, 0.071, 0.152, 0.076]))*timeExpodc_ft_unirr = np.flip(np.array([0.214, 0.114, 0.062, 0.046, 0.038, 0.046, 0.065, 0.054]))*timeExpo  dc_ff_irr = np.flip(np.array([0.010, 0.004, 0.003, 0.002, 0.001, 0.003, 0.002, 0.002]))*timeExpodc_ff_unirr = np.flip(np.array([0.0049, 0.0027, 0.0017, 0.0021, 0.0008, 0.0015, 0.0017, 0.0035]))*timeExpo  dc_ft_irr_T = np.interp(Tinput, T, dc_ft_irr)dc_ft_unirr_T = np.interp(Tinput, T, dc_ft_unirr)dc_ff_irr_T = np.interp(Tinput, T, dc_ff_irr)dc_ff_unirr_T = np.interp(Tinput, T, dc_ff_unirr)print(f'CCD Temperatur {Tinput:.1f}.')print(f'FT, BoL. Dark Current {dc_ft_unirr_T:.3f}.')print(f'FT, EoL. Dark Current {dc_ft_irr_T:.3f}.')#print(f'FF, EoL. Dark Current {dc_ff_irr_T:.3f}.')#print(f'FF, obL. Dark Current {dc_ff_unirr_T:.3f}.')print(f'Event energy {efwhm:.2f}.')# Total noise estimate, now including CTI termnoise_sigma_ft_unirr = np.sqrt((noiseBase*opNoise)**2 + dc_ft_unirr_T**2+ sigma_cti_average_losses**2)fwhm_sigma_tot_ft_unirr = 2.35 * omega * (noise_sigma_ft_unirr**2 + fano * efwhm / omega)**0.5 #+ 2.35 *sigma_cti_average_lossesprint(f"FT, DC BOL. FWHM = {fwhm_sigma_tot_ft_unirr:.2f} eV")noise_sigma_ft_irr = np.sqrt((noiseBase*opNoise)**2 + dc_ft_irr_T**2+ sigma_cti_average_losses**2)fwhm_sigma_tot_ft_irr = 2.35 * omega * (noise_sigma_ft_irr**2 + fano * efwhm / omega)**0.5# + 2.35 *sigma_cti_average_lossesprint(f"FT, DC EOL. FWHM = {fwhm_sigma_tot_ft_irr:.2f} eV")noise_sigma_ff_irr = np.sqrt((noiseBase*opNoise)**2 + dc_ff_irr_T**2+ sigma_cti_average_losses**2)fwhm_sigma_tot_ff_irr = 2.35 * omega * (noise_sigma_ff_irr**2 + fano * efwhm / omega)**0.5 #+ 2.35 *sigma_cti_average_losses#print(f"FF, EOL. FWHM = {fwhm_sigma_tot_ff_irr:.2f} eV")noise_sigma_ff_unirr = np.sqrt((noiseBase*opNoise)**2 + dc_ff_unirr_T**2+ sigma_cti_average_losses**2)fwhm_sigma_tot_ff_unirr = 2.35 * omega * (noise_sigma_ff_unirr**2 + fano * efwhm / omega)**0.5 #+ 2.35 * sigma_cti_average_losses#print(f"FF, BOL. FWHM = {fwhm_sigma_tot_ff_unirr:.2f} eV") # Update threshold value from default to one based on the different noise components, using a 4-sigma or 5-sigma criterium# Threshold estimate for event detection# Includes 2 components:# - Noise base (multiplied by factor for optical bg# - Dark current   # DC EOL THRESHOLD estimate for minimum event detection calculationsnoise_sigma_dcbol = np.sqrt((noiseBase*opNoise)**2 + dc_ft_unirr_T**2)thresh = sigma_th * omega * noise_sigma_dcbolprint(f'New Noise-based Threshold DC BOL {thresh:.3f}.')ny = 110nx = ny // 2xmin = 1xmax = 2255ymin = 1ymax = 4510dx = (xmax - xmin + 1) / nxdy = (ymax - ymin + 1) / nyimg = np.zeros((ny, 2 * nx))eguess = 300.0for j in range(ny):    y = ymin + (j + 0.5) * dy    for i in range(nx):        x = xmin + (i + 0.5) * dx        eout = newton(fcn, eguess,                      args=(thresh, x, y, pctiref, sctiref, eref, beta))        # F-side        img[j, i] = eout        # Mirror E-side        img[j, 2 * nx - i - 1] = eout        # print(x, y, eout)        # Use eout as the next guess        eguess = eoutidx = img < 300good = idx.sum() / img.sizeprint(f" BOL Fraction detecting 300eV or lower {good * 100:.2f}")# DC EOL THRESHOLD estimate for minimum event detection calculationsnoise_sigma = np.sqrt((noiseBase*opNoise)**2 + dc_ft_irr_T**2)thresh = sigma_th * omega * noise_sigmaprint(f'Noise-based Threshold DC EOL {thresh:.3f}.')for j in range(ny):    y = ymin + (j + 0.5) * dy    for i in range(nx):        x = xmin + (i + 0.5) * dx        eout = newton(fcn, eguess,                      args=(thresh, x, y, pctiref, sctiref, eref, beta))        # F-side        img[j, i] = eout                # Mirror E-side        img[j, 2 * nx - i - 1] = eout        # print(x, y, eout)        # Use eout as the next guess        eguess = eoutidx = img < 300good = idx.sum() / img.sizeprint(f" EOL Fraction detecting 300eV or lower {good * 100:.2f}")fig = plt.figure()ax = fig.add_subplot(1, 1, 1)ims = ax.imshow(img, origin='lower', extent=[xmin, 2 * xmax, ymin, ymax])cb = fig.colorbar(ims, ax=ax)cb.set_label("minimum energy (eV)")# cor the contourscy = np.arange(ny) * dy + ymin + dy / 2X, Y=np.meshgrid(cy, cy)cs = ax.contour(X, Y, img, [200, 250, 300])ax.clabel(cs, inline=True, fontsize=10)# chr(10) gives a newline charactertit1 = fr'CTI$_{{p}}$={pctiref}, CTI$_{{s}}$={sctiref}{chr(10)}'tit2 = fr'$\beta$={beta}, threshold={thresh:.2f} (eV)'ax.set_title(tit1 + tit2)ax.set_xlabel('X')ax.set_ylabel('Y')plt.show()